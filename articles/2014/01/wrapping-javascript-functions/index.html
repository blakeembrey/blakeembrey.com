<!DOCTYPE html>
 <html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><title data-react-helmet="true">Wrapping JavaScript Functions • Blake Embrey</title><meta data-react-helmet="true" name="og:type" content="article"/><meta data-react-helmet="true" name="og:title" content="Wrapping JavaScript Functions"/><meta data-react-helmet="true" name="og:site_name" content="Blake Embrey"/><meta data-react-helmet="true" name="og:url" content="http://blakeembrey.com/articles/2014/01/wrapping-javascript-functions/"/><meta data-react-helmet="true" name="description" content="In the modern age of web applications and development, it seems we are constantly adding side effects to every part of our applications - everything from analytics to event triggering. Unfortunately in a lot of cases, we…"/><meta data-react-helmet="true" name="og:description" content="In the modern age of web applications and development, it seems we are constantly adding side effects to every part of our applications - everything from analytics to event triggering. Unfortunately in a lot of cases, we…"/><meta data-react-helmet="true" name="article:published_time" content="2014-01-14T04:00:00.000Z"/><meta data-react-helmet="true" name="twitter:site" content="@blakeembrey"/><style data-react-free-style="true">::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}audio:not([controls]){display:none;height:0}b,strong{font-weight:inherit;font-weight:bolder}button,html [type="button"], [type="reset"],[type="submit"]{-webkit-appearance:button}button,input{overflow:visible}button,input,optgroup,select,textarea{margin:0}button,select{text-transform:none}button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}audio,video,canvas{display:inline-block}dfn{font-style:italic}article,aside,footer,header,nav,section,details,menu,figcaption,figure,main{display:block}figure{margin:1em 40px}h1{font-size:2em;margin:0.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;line-height:1.15}img{border-style:none}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}mark{background-color:#ff0;color:#000}code,kbd,samp,pre{font-family:monospace, monospace;font-size:1em}progress{display:inline-block;vertical-align:baseline}small{font-size:80%}sub{bottom:-0.25em}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}summary{display:list-item}sup{top:-0.5em}svg:not(:root){overflow:hidden}[hidden],template{display:none}textarea{overflow:auto}*{box-sizing:border-box}.hljs-addition{background:#dfd}.hljs-attribute,.hljs-variable,.hljs-body{color:#008080}.hljs-change{background:#0086b3}.hljs-class .hljs-title,.hljs-type,.hljs-literal,.hljs-command{color:#458;font-weight:500}.hljs-deletion{background:#fdd}.hljs-header,.hljs-comment,.hljs-javadoc{color:#969896}.hljs-keyword,.hljs-winutils,.hljs-subst,.hljs-request,.hljs-status{color:#a71d5d}.hljs-built_in,.hljs-number,.hljs-hexcolor,.hljs-constant{color:#0086b3}.hljs-preprocessor,.hljs-pragma,.hljs-pi,.hljs-doctype,.hljs-shebang,.hljs-cdata{color:#999;font-weight:500}.hljs-regexp{color:#009926}.hljs-string,.hljs-tag .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.hljs-formula{color:#df5000}.hljs-symbol,.hljs-symbol .hljs-string,.hljs-special,.hljs-prompt{color:#990073}.hljs-tag,.hljs-tag .hljs-title,.hljs-rules .hljs-property{color:#000080}.hljs-title,.hljs-id,.hljs-preprocessor{color:#795da3}a{border-bottom:2px solid #dcdcdc;color:#111;text-decoration:none}a:hover{border-bottom-color:#f20}body{color:#111;font-family:sans-serif;font-size:17px;font-weight:300;line-height:1.7;margin:0}pre .diff-addition{background-color:#dfd}.hljs-chunk,pre .diff-chunk{color:#aaa}pre .diff-deletion{background-color:#fdd}.f1evzss3{border-top:4px solid #f20}.fsclf6o{margin:0 auto;max-width:640px;padding:20px}.f5tm013{margin:0;padding:30px 0}.f5tm013 > li{display:inline-block;list-style:none;margin-right:20px}.f5qoj4b{border-bottom-color:transparent;color:#333}.f13o7dmr h1, h2, h3, h4, h5, h6{font-weight:500}.f13o7dmr h1{font-size:1.7em}.f13o7dmr h2{font-size:1.3em}.f13o7dmr h3{font-size:1.1em}.f13o7dmr hr{border-bottom:1px dashed #fff;border-top:1px dashed #aaa;display:block;margin:1.5em 0}.f13o7dmr blockquote{border-left:4px solid #f20;margin:1em 0;padding-left:1em}.f13o7dmr img,audio,embed,video,object{height:auto;max-width:100%}.f13o7dmr code, pre{background-color:#f3f3f3;border:1px solid #ccc;color:#111;font-family:monospace;font-size:0.9em}.f13o7dmr pre{line-height:1.3;overflow-x:auto;padding:0.6em 0.8em}.f13o7dmr code{border-color:#ccc;display:inline;padding:0 0.3em;white-space:pre-line;word-wrap:break-word}.f13o7dmr pre > code{background-color:transparent;border:none;font-size:100%;padding:0;white-space:pre;word-wrap:normal}.f13o7dmr a:hover > code{border-color:#f20}.f1ymzfbz{color:#777;font-size:0.85em;margin:1.5em 0;padding:0}.f1ymzfbz > li > a{color:#777}.f1ymzfbz > li{display:inline-block;list-style:none;padding-right:20px}</style></head><body><div id="react-mount"><div data-reactroot="" data-reactid="1" data-react-checksum="1069840068"><!-- react-empty: 2 --><div class="f1evzss3" data-reactid="3"></div><div class="fsclf6o" data-reactid="4"><ul class="f5tm013" data-reactid="5"><li data-reactid="6"><a class="f5qoj4b" href="/" data-reactid="7">Writing</a></li><li data-reactid="8"><a class="f5qoj4b" href="http://blakeembrey.me" data-reactid="9">About</a></li><li data-reactid="10"><a class="f5qoj4b" href="/rss.xml" data-reactid="11">RSS</a></li></ul><div class="f13o7dmr" data-reactid="12"><div data-reactid="13"><!-- react-empty: 14 --><h1 data-reactid="15">Wrapping JavaScript Functions</h1><ul class="f1ymzfbz" data-reactid="16"><li data-reactid="17"><!-- react-text: 18 -->Written<!-- /react-text --><!-- react-text: 19 --> <!-- /react-text --><time datetime="2014-01-14T04:00:00.000Z" data-reactid="20">January 2014</time></li></ul><div data-reactid="21"><p>In the modern age of web applications and development, it seems we are constantly adding side effects to every part of our applications - everything from analytics to event triggering. Unfortunately in a lot of cases, we tend to cram this functionality into function with the useful stuff. As programmers, this causes numerous issues down the line - especially when it comes to refactoring and code comprehensibility.</p>
<p>A simple way to keep this functionality apart from the core code is create a helpful utility function to manage it for you. And to keep our code readability, we shouldn’t allow anything advanced that can break our understanding of the original function. That means we don’t want to be able to alter the original function, but we can still trigger any side effects we need to inline with the original function.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">before, fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    before.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };
};
</code></pre>
<p>To use the function, we can pass any function in as the first argument and the original function we want to wrap as the second argument. For example, we could do <code>before(logger, add)</code>. Even without seeing the <code>logger</code> or <code>add</code> functions, we can imagine what each do. And because we are passing all the arguments to the side effect function, we can do stuff with the information.</p>
<p>One thing I find myself doing is checking what arguments were passed to a certain function. To do this now, we can <code>before(console.log.bind(console), fn)</code>. Now, let’s implement the reverse functionality.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, after</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    after.call(<span class="hljs-keyword">this</span>, result);
    <span class="hljs-keyword">return</span> result;
  };
};
</code></pre>
<p>This is extremely similar to the first example. The main difference is that the first function passed in is the side effect, but now we have the side effect running after our wrapped function. Adapting the previous example, we can now do <code>after(add, logger)</code> and the logger will execute after the result is computed with the same arguments.</p>
<p>One cool thing we could actually do, is to run argument validation in the <code>before</code> function. Consider this.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> validAdd = before(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[i] !== <span class="hljs-string">'number'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Expected a number'</span>);
    }
  }
}, add);
</code></pre>
<p>We can also put these two functions together and create a new utility. This one allows us to pass both a function before and after our core functionality. E.g. <code>around(logger, add, logger)</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> around = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">over, fn, under</span>) </span>{
  <span class="hljs-keyword">return</span> before(over, after(fn, under));
};
</code></pre>
<h2>Allow unlimited before and after functions</h2>
<p>We can also adapt the functions to accept a variable number of arguments as the <code>before</code> and <code>after</code> functions. However, we can’t do this to the <code>around</code> utility since we wouldn’t know which argument is the core function.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> __slice = <span class="hljs-built_in">Array</span>.prototype.slice;

<span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-regexp">/* ...before, fn */</span></span>) </span>{
  <span class="hljs-keyword">var</span> fn     = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> before = __slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; before.length; i++) {
      before[i].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };
};

<span class="hljs-keyword">var</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn <span class="hljs-regexp">/*, ...after */</span></span>) </span>{
  <span class="hljs-keyword">var</span> after = __slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; after.length; i++) {
      after[i].call(<span class="hljs-keyword">this</span>, result);
    }

    <span class="hljs-keyword">return</span> result;
  };
};
</code></pre>
<h2>Advanced wrapping utility</h2>
<p>So far we’ve seen some function wrapping utilities that are purely for side effects. They have no capability to alter the main function arguments or change the function result. For something more advanced than trigger side-effects, we might to want to use something a little different.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> __slice = <span class="hljs-built_in">Array</span>.prototype.slice;

<span class="hljs-keyword">var</span> wrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, wrap</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> wrap.apply(<span class="hljs-keyword">this</span>, [fn].concat(__slice.call(<span class="hljs-built_in">arguments</span>)));
  };
};
</code></pre>
<p>This is actually pretty similar the <code>wrap</code> function used in Prototype.js. It allows us to call a custom wrapper function with the original function and all the arguments. But, how do we even use this?</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> addAndMultiplyBy2 = wrap(add, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">originalFn, a, b</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * originalFn(a, b);
});
</code></pre>
</div><hr data-reactid="22"/><p data-reactid="23"><strong data-reactid="24">Questions?</strong><!-- react-text: 25 --> <!-- /react-text --><!-- react-text: 26 -->Ask me on<!-- /react-text --><!-- react-text: 27 --> <!-- /react-text --><a href="https://twitter.com/blakeembrey" data-reactid="28">Twitter</a><!-- react-text: 29 --> <!-- /react-text --><!-- react-text: 30 -->or in<!-- /react-text --><!-- react-text: 31 --> <!-- /react-text --><a href="https://github.com/blakeembrey/writing" data-reactid="32">my repo</a><!-- react-text: 33 -->.<!-- /react-text --></p></div></div></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', "UA-22855713-2", 'auto');
          ga('send', 'pageview');</script></body></html>